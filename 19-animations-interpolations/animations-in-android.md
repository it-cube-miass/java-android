Обычный способ создания анимации в Android - это использование XML. Мы можем писать xml-анимации, а затем загружать и воспроизводить их в Java на указанном виджете пользовательского интерфейса. Так, например, мы можем написать анимацию, которая приводит к появлению/исчезанию пять раз в течение трех секунд, а затем воспроизвести эту анимацию на **ImageView** или любом другом виджете. Мы можем рассматривать эти xml-анимации как сценарий, поскольку они определяют тип, порядок и время выполнения.

Давайте рассмотрим некоторые из различных свойств, которые мы можем назначить нашим анимациям.

## Разработка анимации в XML
Итак, мы узнали, что XML помимо описания макетов, также может быть использован для описания анимации, но давайте выясним, как именно. Мы можем указать свойства анимации, которые описывают начальный и конечный внешний вид виджета. Затем XML может быть загружен нашим Java-кодом путем ссылки на имя XML-файла, содержащего его, и превращения его в полезный объект Java; Это не так уж сильно отличается от работы с макетом пользовательского интерфейса.

Вот краткий обзор некоторых пар свойств анимации, которые мы можем указать для создания анимации. Сразу после того, как мы рассмотрели некоторые, мы разберем, как использовать его в Java.

### Исчезание
Alpha - это мера прозрачности. Таким образом, указывая начальное значения fromAlpha и конечное toAlpha, мы можем устраивать появление/исчезновение элементов. Значение ```0.0``` является невидимым, а ```1.0``` - полностью видимым. Постоянное изменение между значениями создает эффект появления/исчезновения:
```xml
<alpha 
    android:fromAlpha="0.0"
    android:toAlpha="1.0" />
```

### Перемещение
Мы можем переместить объект в пределах нашего пользовательского интерфейса, используя аналогичную технику; Свойства **fromXDelta** и **toXDelta** могут иметь значения, установленные в процентах от размера анимируемого объекта.
```xml
<translate
    android:fromXDelta="-100%"
    android:toXDelta="0%"/>
```
Кроме того, существуют свойства **fromYDelta** и **toYDelta** для анимации вверх и вниз.

### Маштабирование или растяжение
Значения **fromXScale** и **toXScale** увеличивают или уменьшают масштаб объекта. Например, следующий код анимированно изменит объект, с нормального размера на невидимый: 
```xml
<scale
    android:fromXScale="1.0"
    android:fromXScale="0.0"/>
```

### Контроль длительности
Конечно, ни одна из этих анимаций не была бы особенно интересной, если бы они просто мгновенно пришли к своему окончанию. Чтобы сделать наши анимации более интересными, мы можем устанавливать их длительность в миллисекундах. Мы также можем упростить синхронизацию, особенно по отношению к другим анимациям, установив **startOffset**, также в миллисекундах.

Следующий код будет начинать анимацию через треть секунды после того, как мы ее запустим, и длительность ее будет две трети секунды:
```xml
android:duration="666"
android:startOffset="333"
```

### Вращение
Если вы хотите что-то покрутить, используйте **fromDegrees** и **toDegrees**. Cледующий код будет вращать виджет по полному кругу:
```xml
<rotate 
    android:fromDegrees="360"
    adnroid:toDegrees="0"/>
```

### Повторение
Повторение может быть важным в некоторых анимациях, например, эффект колебания или встряски, поэтому мы можем добавить свойство **repeatCount**. Кроме того, мы можем указать, как анимация повторяется, установив **repeatMode**.

Следующий код будет повторять анимацию 10 раз, каждый раз меняя направление анимации. Свойство **repeatMode** относится к текущему состоянию анимации. Это означает, что если вы, например, повернете кнопку от 0 до 360 градусов, то вторая часть анимации (первый повтор) будет вращаться в другую сторону, от 360 градусов назад до 0. Третья часть анимации (второй повтор) снова перевернется и повернется от 0 до 360 градусов:
```xml
android:repeatMode="reverse"
android:repeatCount="10"
```

### Комбинирование свойств анимации с Set
Для объединения этих эффектов в группы, нам нужен **Set**. Этот код показывает, как мы можем объединить все предыдущие фрагменты кода, которые мы только что видели, в реальную XML- анимацию, которая будет компилироваться: 
```xml
<?xml version=" 1.0 "encoding=" utf-8"?>
<set xmlns:android="http://schemas.android.com/apk/res/android" 
... Все наши анимации идут сюда: 
</set>
```
Мы до сих пор не видели никакого Java-кода, с помощью которого можно было бы оживить эти анимации. Давайте это исправим.

## Создание экземпляров анимации и управление ими с помощью кода Java
Следующий фрагмент кода Java показывает, как мы объявляем объект типа **Animation**, инициализируем его анимацией, содержащейся в xml-файле с именем ```fade_in.xml```, и запускаем на **ImageView**. 
```java
Animation animFadeIn;
animFadeIn = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.fade_in);
ImageView imageView = (ImageView) findViewById(R.id.imageView);
imageView.startAnimation(animFadeIn);
```
Вскоре мы сделаем это в проекте, и посмотрим, где также можно разместить XML- анимацию:

У нас уже есть довольно мощный арсенал анимаций и функций управления продолжительностью. Но Android API дает нам немного больше, чем это.

## Дополнительные функции анимации
Мы можем слушать состояние анимации так же, как мы слушаем другие события в UI. Мы также можем использовать интерполяторы (interpolators), чтобы сделать нашу анимацию более реалистичной и приятной. Давайте сначала посмотрим на слушателей.

### Слушатели
Если мы реализуем интерфейс **AnimationListener**, мы можем прослушивать состояние анимации, переопределив три метода, которые сообщают нам, когда что-то происходит. Основываясь на этих событиях, мы можем как-то действовать.

**OnAnimationEnd** вызывается при завершении анимации, **onAnimationRepeat** вызывается каждый раз, когда анимация начинает повторяться, **onAnimationStart** вызывается, когда анимация начинается. Это может быть не то же время, когда вызывается **startAnimation**, если установлено свойство **startOffset**:
```java
    @Override
    public void onAnimationStart(Animation animation) {
        // какие-то действия
    }

    @Override
    public void onAnimationEnd(Animation animation) {
        // какие-то действия
    }

    @Override
    public void onAnimationRepeat(Animation animation) {
        // какие-то действия
    }
```
> Скоро, в демонстрационном приложении, мы увидим, как **AnimationListener** работает.

### Интерполяторы анимации
Когда мы анимируем что-то с постоянной скоростью, то, на первый взгляд все кажется нормальным. Но если мы сравним такую анимацию с другой, которая использует постепенное ускорение, то последняя почти наверняка будет более приятной для просмотра.

Вполне возможно, что если бы нам не сказали, что единственная разница между двумя анимациями заключается в том, что одна использует ускорение, а другая - нет, мы не смогли бы сказать, почему мы предпочитаем ту, что использует успорение. Наш мозг более восприимчив к вещам, которые соответствуют нормам окружающего нас мира. Вот почему небольшое добавление реальной физики, такой как ускорение и замедление, улучшает нашу анимацию.

Однако последнее, что мы хотим делать, - это начинать производить кучу математических вычислений, чтобы просто сдвинуть кнопку на экране или прокрутить какой-то текст по кругу.

Вот тут-то и помогают интерполяторы. Это модификаторы анимации, которые мы можем установить с помощью одной строчки кода в xml-файле.

Пример **accelerate_interpolator** и **cycle_interpolator**
```xml
android:interpolator="@android:anim/accelerate_interpolator"
android:interpolator="@android:anim/cycle_interpolator"
```
> Вы можете узнать больше о интерполяторах и классе **Animation** в Android [здесь](https://developer.android.com/guide/topics/resources/animation-resource.html)
