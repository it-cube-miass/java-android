Подумайте, что будет, если у вас есть метод, поведение которого не зависит от значения переменной экземпляра.

Возьмем, к примеру, метод round() из класса Math. Он всегда делает одно и то же - округляет дробное число (которое передается в виде аргумента) до ближайшего целого. Если из 10000 экземпляров класса Math, вызвать метод round(42.2), результатом всегда будет целое число 42. Иными словами, метод зависит не от состояния переменной экземпляра, а от аргумента. Единственное значение, влияющее на работу метода round(), - это аргумент, который ему передается.

Метод round(), а так же min() max() abs() и прочие методы класса Math не используют значения переменных экземпляра. На самом деле класс Math вообще не содержит переменных экземпляра, поэтому от создания его экземпляра нет никакой пользы. Но вам и не нужно этого делать. Более того, у вас это не получиться.  
```java
int x = Math.round(42.2);   //42
int y = Math.min(56, 12);   //12
int z = Math.abs(-343);     //343
```
Методы из класса Math статические и для работы с ними вам не нужно иметь экземпляр класса Math. Вам необходим сам класс.

## Разница между обычными и статическими методами
Java - объектно ориентированный язык, но иногда возникают ситуации, когда экземпляр класса не нужен (как в случае с методами из класса Math). Ключевое слово static позволяет методу работать без экземпляра класса. Статический метод подразумевает, что его поведение не зависит от переменных экземпляра, поэтому нет необходимости в экземпляре/объекте. Нужен просто класс.

![картика с диаграммой классов и объектов]()

Статический метод вызывается с помощью имени класса. Обычный метод вызывается с помощью имени ссылочной переменной.

## Статические методы не могут использовать не статические переменные!
Статические методы работают, не зная о конкретных экземплярах своего класса. Поскольку статические методы вызываются из класса (Math.round()), а не через ссылку на объект (d1.bark()), они не могут использовать переменные класса. Статический метод не знает, в каком экземпляре хранится нужное ему значение переменной.

```java
class Dog {
    private int size;

    public void setSize(int value) {
        size = value;
    }

    public int getSize() {
        return size;
    }

    public static void printSize() {
        System.out.println("Размер утки равен" + size); //Какая собака? Чей размер?
    }
}

public class DogTest {
    public static void main (String[] args) {
        Dog.printSize();
    }
}
```

## Статические методы не могут использовать не статические методы!
Что делают не статические методы? Они обычно используют состояние переменных экземпляра, влияющих на их поведение.
```java
class Dog {
    private int size;

    public void setSize(int value) {
        size = value;
    }

    public int getSize() {
        return size;
    }

    public static void printSize() {
        System.out.println("Размер собаки равен " + getSize());
    }
}
```
Метод getSize() возвращает значение переменной экземпляра size. Но чей это размер?

## Статическая переменная: одно и то же значение для всех экземпляров класса
Представьте, что вам захотелось посчитать, сколько всего все объекты Dog пролаяли. Как вы это сделаете? Может быть с помощью переменной, которая будет инкрементироваться в методе bark()?
```java
class Dog {
    private int countBark;

    public void bark() {
        countBark++;
    }
}
``` 
Это не сработает, потому что countBark - переменная экземпляра, и для каждого экземпляра Dog она будет иметь начальное значение 0. Нужен класс с единственной общей копией переменной для всех своих экземпляров.

Именно это предоставляет вам статическая переменная: значение, общее для всех экземпляров класса, то есть одно значение на класс вместо одного значения на экземпляр.

![картинка диаграммы с объектами Dog]()

```java
class Dog {
    private static int countBark;

    public void bark() {
        countBark++;
    }
}
```
Объекты Dog не хранят свою копию переменной countBark. Поскольку это статическая переменная, она будет доступна для всех объектов Dog в единственном экземпляре. Можете считать, что статическая переменная живет в классе, а не в объекте.  
Статические переменные получают значения по умолчанию так же, как обычние.  

## Статические финализированные переменные - константы
Если переменна япомечена модификатором final, то после инициализации она уже никогда не сможет измениться. Иначе говоря, значение статической финализированнной переменной будет неизменным, пока класс загружен. Взгляните на Math.PI из стандартной библиотеки
```java
public static final double PI = 3.141592653589793;
```
Переменная помечена как public, поэтому любой код может получить к ней доступ.  
Переменная помечена как static, поэтому вам не нужен экземпляр класса Math.  
Переменная помечена как final, так как PI не меняется (по крайней мере в Java).

Нет другого способа объявлять переменные в качестве констант, но существует соглашение об именовании, которое поможет вам их разпознать. **Имена констант должны быть написаны в верхнем регистре!**

## Модификатор final подходит не только для статических переменных
Ключевое слово final можно применять и для обозначения не статических переменных, включая переменные экземпляра, локальные переменные и даже параметры методов. И это всегда будет иметь один и тот же смысл: значение не может изменяться.
```java
class Foo {
    final int size = 3; // теперь вы не можете менять размер
    final int whuffie;

    void doWhuffie() {
        whuffie = 42; // теперь нельзя изменить значение переменной whuffie 
    }

    void doStmth(final int x) {
        // Вы не можете изменить x
    }

    void doMore() {
        final int z = 7; // Вы не можете изменить z
    }
}
```


