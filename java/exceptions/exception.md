Исключения - это событие, которое случается в процессе работы программы и прерывает стандартный ход ее исполнения. Программа переходит в специальный режим, поиска обработчика внештатной ситуации. Такой обработчик может предпринять какие-то действия и вернуть программу в штатный режим работы.

Но если обработчика не нашлось JVM всё-таки завершит программу, но обеспечит достаточно подробный диагностический вывод, по которому если не пользователь, то хотя бы программист поймет куда копать.

Исключения поддержаны на уровне языка Java, т.е. ключевых слов и синстаксических конструкций. Кроме того, они используются на уровне виртуальной машины, которая сообщает о многих своих проблемах бросая исключения. Разумеется вся стандартная библиотека тоже активно использует исключения.

Вот несколько самых популярных исключений:

java.lang.NullPointerException
```java
Object nullRef = null;
nullRef.toString();
```
NullPointerException, или просто NPE. Это исключение выбрасывается JVM, когда обращение идет по нулевой ссылке. Другими словами, есть переменная ссылочного типа, где лежит null. Потом пытаются по этой ссылке вызвать метод или обратиться к полю. В ответ виртуальная машина кинет такое исключение. Которое, при отсутствии обработчика приведет к аварийной остановке и распечатке в консоли информации об исключении.

java.lang.ArrayIndexOutOfBoundsException 
```java
int[] arr = {1, 2, 3};
arr[4] = 5;
```
ArrayIndexOutOfBoundsException, случается если попытаться обратиться к несуществующему элементу массива. По отрицательному индексу или по индексу большему или равному длине массива. Аналогичное исключение StringOutofBoundsException случиться если обратиться к несуществующему символу в стоке. 

Исключениями представленны и разные ошибки самой виртуальной машины. Например, когда JVM не хватает памяти на создание нового объекта, она бросает исключение типа OutOfMemoryError, которое даже можно попытаться обработать. Другое дело, что обычно делать этого не стоит, потому что в этой ситуации предпринять что-то разумное довольно проблематично.

## Объект исключение
Исключение в Java - это объект, экземпляр какого-то класса. Все классы исключений наследуются от java.lang.Throwable, который в свою очередь наследуется от Object.

Ключевое свойство экземпляров Throwable и его подклассов - это возможность быть "брошенными". Бросине выглядит следующим образом
```java
throw new IllegalStateException("Invalid user. Please replace user and continue.");
``` 
Ключевое слово throw и за ним любое выражение типа Throwable. Обычно здесь просто создается экземпляр нового исключения. 

Важный момент. Stack trace, который мы видим при печати такого исключения, определяется тем, где был создан экземпляр исключения, а не тем откуда оно было выброшено. 

У класса исключений, традиционно, есть конструктор принимающий строку сообщения. Это сообщение, поясняющее проблему, будет напечатано вместе со stack trace-ом.  

## Классификация исключений
Исключения в Java деляться на три группы. Вот они, с учетом иерархии наследования.

![картинка]()

Error и подклассы - это ошибки виртуальной машины. Например:
- java.lang.OutOfMemoryError - виртуальной машине не хватило памяти
- java.lang.NoClassDefFoundError - виртуальная машина не смогла найти какой-то из классов, на который ссылается ваша программа
- java.lang.VerifyError - означает, что класс найден, но там что-то не так с байт-кодом

JVM таким образом сообщает, что ей стало плохо, хотя и не настолько, чтобы сразу умереть. Общее у этих ошибок то, что и не надо пытаться обрабатывать. Помочь виртуальной машине вы скорее всего уже не сможете. 

Exception и RuntimeException соответствуют ошибкам уровня программы. Неккоректные параметры, неккоректное состояние, недопустимое действие. Ошибки такого сорта можно пытаться уже хоть как-то обрабатывать. 

Разница между ними состоит в том, что Exception и его подклассы являются проверяемыми (checked), а RuntimeException и его подклассы непроверяемыми (unchecked).

### Проверяемые исключения
Проверяемые исключения являются предметом особого контроля компилятора. Он внимательно следит за тем, чтобы такие исключения декларировались и обрабатывались.

Характерный пример проверяемого исключения IOException, ошибка ввода/вывода.
```java
public class ExceptionDemo {
    public void someMethod() {
      //
      throw new IOException("Failed to read file");
      //
    }
}
```
Если попытаться бросить такое исключение, как в этом примере, то код не скомпилируется. Компилятор будет требовать, чтобы, либо в этом же методе был обработчик этого исключения, либо на методе было явно написано, что из него может вылетать IOException.

Написать это можно следующим образом
```java
public class ExceptionDemo {
    public void someMethod() throws IOException {
      //
      throw new IOException("Failed to read file");
      //
    }
}
```
Когда мы напишем это на методе, то аналогичная проверка будет выполнена компилятором и во всех местах вызова нашего метода. Т.е. либо IOException должен быть сразу обработан, либо возможность его вылета обозначена в объявлении всех методов вызыщающих наш метод. Таким образом компилятор обеспечивает, что в сигнатуре метода, видны все проверяемые исключения, которые могут из него вылетать. Их может быть несколько, перечисленных через ','

### Непроверяемые исключения
Непроверяемые исключения такого внимания компилятора не получают. Их можно свободно бросать из любой точки программы не декларируя.

Примеры непроверяемых исключения
- java.lang.NullPointerException
- java.lang.ArrayIndexOutOfBoundsException
- java.lang.ArithmeticException - вылетает при делении на 0

Такие ошибки могут случиться в любой точке программы и было бы крайне неудобно если бы компилятор требовал везде их явно декларировать или обрабатывать. 

