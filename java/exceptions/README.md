В любой программе может случиться ошибка. Для этого есть 100500 причин. Может быть пользователь ввел неправильные данные, может отвалилась необходимая программе база данных или другой важный сетевой ресурс, может сбоит чип оперативной памяти и случайным образом портит данные в нем хранящиеся. 

Причины могут быть разные, но непреложный факт состоит в том, что от всех ошибок не застраховаться, а следовательно нашим программам иногда приходиться с ними сталкиваться и как-то на них реагировать. 

В разных языках существует разная культура обработки ошибок, определяемая как возможностями языка/платформы, так и сложившимися традициями. 

Чтобы дальнейший рассказ не был слишком теоритическим, давайте рассмотрим такой пример. Предположим вы пишите подключаемую в разные программы библиотеку, вычисляющую математические выражения.

Лицо это библиотеки интерфейс Calculator и какая-то его реализация. 
```java
public interface Calculator {
    double calculate(String expr)
}
```
В интерфейсе есть метод calculate(), принимающий строку с выражением expr и возвращающий double, вычисленное значение выражения.

И вот в выражении поданном на вход, содержиться ошибка, например в нем встречается число, где в качестве десятичного разделителя используется запятая вместо точки.
```java
//
calculate("100,500 * 7");
//
``` 
Как калькулятору на это реагировать?

Самой простой по реализации, но и самой плохой по последствиям, это вызов System.exit(1);
```java
public class CalculatorImpl implements Calculator {
    @Override
    public double calculate (String expr) {
        //
        System.exit(1);
        //
    }
}
```
Программа немедленно завершиться, упадет по сути, потеряв все накопленные в памяти данные. Раз и все, нету ни программы ни данных. Я имею в виду всю большую программу, включающую калькулятов в качестве одного из своих компонентов.

Недостатки такого поведения, думаю понятны. Программа рухнула, пользователю придеться ее перезапускать и начинать все, что он делал с начала. Хорошо еще, если программа сообщает в чем причина ошибки, а то, как пользователь догадается, что на самом деле, программа упала потому, что неделю назад он ввел где-то число в неправильном формате. В общем System.exit() это не самое дружественное поведение со стороны нашей библиотеки калькулятора. 

Есть способ немного получше. В случае ошибки в выражении, наша библиотека будет возвращать в качестве результата какое-то специальное значение. Например NaN. По которому вызывающая сторона поймет, что случилась ошибка.
```java
public class CalculatorImpl implements Calculator {
    @Override
    public double calculate (String expr) {
        //
        return Double.NaN;
        //
    }
}
```
Но нужно, чтобы у возвращаемого типа было свободное значение, которое можно зарезервировать под ошибку. Это не всегда возможно, например генератор случайных чисел может сгенерировать обсалютно любое число. Где нам взять отдельное значение под ошибку? А если видов ошибок несколько и их надо различать, то потребуется несколько значений.

Да и в нашем случае, NaN может совершенно законно получиться при некоторых вычислениях, например, при делении 0 на 0 или при умножении 0 на бесконечность. Вообщем, как обозначить ошибку непонятно. Плюс даже если бы мы выделили какое-то специальное значение, то вызывающий код некрасиво оброс бы if-ми для своевременного отлова этой ошибки.

Чтобы обойти проблему с резервированием значения под ошибку в возвращаемом типе можно пойти дальше и возвращать не double, а простенький объект-пару, состоящий из числа результата и признака ошибки. 
```java
class Result {
    double value;
    boolean isError;
}

public class CalculatorImpl implements Calculator {
    @Override
    public Result calculate (String expr) {
        //
        return new Result();
        //
    }
}
```
Тогда весь диапазон типа результат будет использоваться по своему назначению, правда if-ы для отслеживания ошибки в вызывающем коде кикуда не денуться.

Все эти способы уведовления вызывающей программы о слущившихся ошибках имют серьезные недосткаки. К счастью есть решение, которое их лишено и оно состоит в использовании исключений.
