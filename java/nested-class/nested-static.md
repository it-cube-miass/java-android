Статический вложенный класс определяется внутри другого внешнего класса.  
Это может выглядеть так
```java
class OuterClass {
    static class NestedClass {
    }
}
```
Осталось понять зачем это нужно :)  
И для этого рассмотрим пример.

Есть у нас вот такой класс Human, для нашей социальной сети :).
```java
class Human {
    String name;
    int age;
    boolean married;

    public Human(String name) {
        this.name = name;
    }
}
```
У него есть имя, возраст и состояние married. Вообщем-то никаких проблем на первый взгляд и нет, но, что если нам захочется в какой-то момент времени сделать состояние его отношений с другими людми более сложным, а не только женат или не женат. 

Это можно решить вводом нового класса Relations
```java
class Human {
    String name;
    int age;
    Relations relations;
}

class Relations {
    String name;
    Human human;

    public Relations(String name) {
        this(name, null);
    }

    public Relations(String name, Human human) {
        this.name = name;
        this.human = human;
    }
}
```
Вроде бы, все классно. У нас появились возможности отношений. И на первый взгляд тут даже проблем нет. Но это только на первый взгляд.  
Дело в том, что Relations, если подумать, жестко привязан к Human. Скорее всего, во всей программе, нет ни одного места, где эти Relations еще бы использовались.  
Более того, название Relations (отношения) подразумевает не только отношения между людми, это могут быть еще другие отношения. В результате, если кто-то рефакторит класс Human, ну например перемечает его из одного пакета в другой, он может на полном серьезе проигнорировать и забыть перенести в другой пакет класс Relations, просто не поняв, что это Human Relations.  
И хотелось бы иметь возможность показать тому, кто читает код, что эти Relations, в этой программе, используются вот с этим классом Human и ни с каким другим. 

Мы можем взять класс Relations и вложить внутрь класса Human. Получив
```java
class Human {
    String name;
    int age;
    Relations relations;

    static public class Relations {

        String name;
        Human human;
        //...
    }
}
```
Класс Relations просто находится внутри тела класса Human. Единственное отличие, добавляется ключевое слово static.

Теперь мы 100% привязали наш Relations к Human. Любой кто рефакторит этот код, не может перетянуть Human, оставив Relations. Потому что Relations теперь гвоздями прибит в Human.

Пример использования
```java
public class HumanTest {
    public static void main(String[] args) {

        Human h1 = new Human("Маша");
        Human h2 = new Human("Петя");
        h2.relations = new Human.Relations("Все сложно", h1);
    }
}
```
Обратите внимание, как мы создаем экземпляр класс Relations. Нам необходимо указать родительский класс Human, потом оператор доступа ".", потому, что вложенный класс Relations с ключевым словом static это не более чем статический член класса Human.  
Благодаря этой записи, любой читающий прекрасно поймет, что эти Relations относятся к Human.

Статические вложенные классы (nested static) очень похожи на классы верхнего уровня. Их обычно используют если необходимо логически связать два класса – внешний и внутренний.
 
Вложенность статических классов может быть сколь угодно большая.
