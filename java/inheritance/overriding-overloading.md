Переопределяя метод, принадлежащий родительскому классу, вы подписываете контракт. Например, в нем говорится: "Я не принимаю никаких аргументов и возвращаю булево значение". Иными словами, аргументы и возвращаемые значения переопределяемых методов внешне должны выглядеть точно так же, как в оригинальном методе родительского класса.  
**Метод - это и есть контракт**

## Правила переопределения
1. Аргументы должны совпадать, а типы возвращаемых значений должны быть совместимы.  
Контракт для родительского класса определяет, как остальной код сможет использовать метод. Что бы он ни принимал в качестве аргументов, дочерний класс, переопределяя его, должен применять такие же аргументы. И что бы он ни возвращал, переопределенный метод должен возвращать значение того же или дочернего типа. Помните, объект дочернего класса обязан уметь все, о чем объявил его родитель, поэтому безопасно возвращать дочерний класс в ситуациях, когда ожидается класс-родитель.

2. Метод не может быть менее доступным.  
Это означает, что уровень доступа должен быть таким же или менее строгим. Например, вы не можете переопределить публичный метод, сделав его приватным. Представьте, какой сюрприз получит внешний код, вызывая, как он считает на уровне компиляции, публичный метод, если внезапно во время выполнения программы JVM закроет дверь перед его носом, потому что вызванная переопределенная версия метода приватна!

## Перегрузка метода
Перегрузка метода - это не что иное, как наличие нескольких методов с одним именем, но разными наборами аргументов. И все. В процессе перегрузки методов полиморфизм не задействуется!

Перегрузка позволяет создавать несколько версий одного метода с разным списком аргументов, делая их более удобными для вызова. Например, если у вас есть метод, который принимает только тип int, то перед вызовом этого метода код должен преобразовать, скажем, double в int. Перегрузив метод и добавив новую версию, принимающую double, вы упростите его вызов для внешнего кода.

Хотя перегруженные методы и не пытаются соблюдать контракт для выполнения условий полиморфизма, они обладают гораздо большей гибкостью.

## Правила перегрузки

1. Типы возвращаемых значений могут быть разными.  
Вы можете изменять типы возвращаемых значениий в перегруженных методах. При этом список аргументов тоже должен отличаться.

2. Вы не можете изменить только тип возвращаемого значения.  
Если изменить лишь тип возвращаемого значения, это будет некорректная перегрузка - компилятор решит, что вы пытаетесь переопределить метод. Кроме того, это считается недопустимым, так как типы возвращаемых значений в дочернем классе и его родителе должны совпадать. Чтобы перегрузить метод, нужно изменить набор аргументов. При этом можно заменить тип возвращаемого значения любым другим.

3. Вы можете как угодно изменять уровни доступа.  
При перегрузке есть возможность добавлять новые версии метода с более ограниченным доступом. Это не имеет значения, так как новый метод не обязан выполнять контракт перегружаемого метода.

Пример корректной перегрузки методов:
```java
```

## Аннотация @Override
Хорошая практика, ставить на переопределенных методах аннотацию @Override. Она явно декларирует ваше намерение переопределить одноименный метод базового класса.
```java
```  
Это может показаться избыточным, ведь переопределение происходит независимо от наличия аннотации. Однако это полезно для дополнительной самопроверки. Например можно ошибиться в имени метода, или в его параметрах, и таким образом создать самостоятельный метод не перекрывающий метод базового класса. Или объявление базового класса, может изменится без вашего ведома, и сигнатуры методов разойдутся. При наличии аннотации @Override компилятор сразу укажет вам на эту проблему. 
