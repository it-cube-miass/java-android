Используя при проектировании наследование, вы получаете множество возможностей ООП.

1. Вы избавляетесь от дублирования код абстрагируя общее поведение для группы классов и помещая его в один класс-родитель. 

Если вам понадобится изменить такой код, то придется сделать это только один раз и в одном метсе, и изменения магическим образом отразятся на всех классах, наследующих это поведение. И все. Не нужно трогать дочерние классы!  
Конечно, магия здесь ни при чем :)

2. Вы определяете общий протокол для группы классов.

Благодаря наследованию вы можете гарантировать, что все классы, сгруппированные под одним родительским типом, содержат все методы этого типа. Другими словами, вы определяете общий протокол для набора классов, связанных наследованием.

Определяя в родительском классе методы, которые могут быть унаследованы дочерними классами, вы сообщаете другому коду о существовании протокола, в котором говорится: "Все мои подтипы (т.е. дочерние классы) могут делать **это** благодаря методам, которые выглядят вот так..."  
Если говорить кратко, вы заключаете контракт.

![](assets/is-a.png)

Класс **Shape** устанавливает общий протокол для всех своих подтипов. Это говорит всем, что любой **Shape** может выполнить действия **getColor** и **getArea**.  
Когда мы говорим *любой Shape*, то имеем в виду класс **Shape** и любой другой класс, который его наследует. Что также означает любой класс, относящийся к **Shape** в каком-либо участке иерархии наследования.

3. Самое интересное - **Полиморфизм**   

Когда вы объявляете общий тип для группы классов, вы можете заменять родительский класс дочерним везде, где предполагается его присутствие.

Простите, что?

Не волнуйтесь, объяснение только началось :)

## Как работает полиморфизм
Чтобы понять работу полиморфизма, нужно немного вернуться назад и вспомнить, как обычно объявляются ссылки и создаются объекты
```java
     (1)      (3)   (2)
Circle myCircle = new Circle();
```
1. Объявляем ссылочную переменную. Говорим JVM, что она должна выделить место в памяти для ссылочной переменной и назвать ее ```myCircle```. Ссылочна переменная навсегда получает тип **Circle**. Иными словами, создаем пульт управления, у которого есть кнопки для работы с объектом **Circle**, а не **Cat**, **Button** или **Socket**.
2. Создаем объект. Говорим JVM выделить память в куче для объекта **Circle** и создает его.
3. Связываем объект и ссылку. Присваиваем ссылочной переменной ``myCircle`` новый объект типа **Circle**. Другими словами, связываем пульт управления с конкретным объектом.

Важно отметить, что типы ссылки и объекта совпадают. И ссылка и объект имеют тип **Circle**.

Однако, полиморфизм допускает, что ссылка и объект могут иметь разные типы.
```java
Shape myCircle = new Circle();
```
Благодаря полиморфизму тип ссылки может быть родительским для типа самого объекта.  
При объявлении ссылочной переменной ей можно присвоить любой объект, который проходит проверку на соответствие для типа этой ссылки. Иными словами, все, что расширяет тип объявленной ссылочной переменной, может быть ей присвоено.

Это позволяет создавать такие объекты, как, например, полиморфные массивы.
```java
Unit[] units = new Unit[5]; // (1)

units[0] = new Robot();
units[1] = new Wizard();
units[2] = new Knight();  // (2)
units[3] = new Dragon();
units[4] = new Vampire();

for (int i = 0; i < units.length(); i++) {
    units[i].greet();  // (3)
    units[i].scream();  
}
```
1. объявляем массив типа Unit, то есть массив, который будет хранить объекты типа Unit.
2. Но посмотрите, что происходит... Мы можем поместить экземпляр любого потомка Unit в массив типа Unit!
3. Проходясь в цикле по массиву, вызываем методы класса Unit, и каждый объяект делает все как положено!

## Полиморфные аргументы и типы возвращаемых значений
Если вы можете объявить ссылочную переменную родительского типа (например Unit) и присвоить ей объект дочернего типа (скажем Dragon), то подумайте, как это может сработать, когда ссылка представляет собой аргумент для метода...
```java
```
<!-- написать код и изменить Vet -->
Параметр Unit может принимать в качестве аргумента любой тип. Класс Vet, в методе kill, вызывает из Unit метод sigh(), и какой бы потомок Unit ни находился в куче, он запускает свою версию sigh().

Благодаря полиморфизму можно писать код, который не придется менять с появлением в программе новых типов дочерних классов.

## Приведение типов
Дословно полиморфизм означает "много форм".  
Вы можете относится к Wizard как к Wizard или как к Object.

Ссылка - это пульт управления, и он принимает все больше и больше кнопок, когда вы двигаетесь вниз по иерархии наследования. 

![картинка пультов]()

Пульт типа Object имеет несколько кнопок - для публичных методов Object. Однако пульт типа Unit включает в себя все кнопки класса Object, а также новые кнопки класса Unit. Чем больше у класса особенностей, тем больше у него может быть кнопок.

Имея на руках экземпляр класса Wizard, мы может присвоить его в переменную базового класса Unit или Object.

Такое присваивание всегда возможно и не требует оператора приведения типа.

При этом объект находящийся по ссылке никак не меняется, он продолжает оставаться экземпляром Square. Просто мы начинаем c ним работать через ссылку более общего типа.

Через эту ссылку нельзя вызывать ничего специфичного для класса Wizard, но можно вызывать все, что объявлено на уровне класса Unit или его родителей.

Приведение типа в обратную сторону от базового класса к классу наследника возможно только явно, при помощи оператора приведения типа. Причем если мы не угадали с типом объекта, т.е. указали класс не являющийся классом наследником, то произойдет ошибка во время исполнения программы.
