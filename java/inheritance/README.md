Одна из фундаментальных концепций ООП это наследование. Речь идет о том, чтобы классы создавать не с нуля, а наследуя или расширяя другие классы.

При проектировании с использованием наследования вы помещаете общий код в один абстрактный класс и объявяете его родителем для других, более специфических классов. Когда один класс наследует другой, это означает, что дочерний класс наследует родительский.

![диаграмма классов до наследования]()

В Java мы говорим, что дочерний класс расширяет родительский. Подобные отношения подразумевают, что дочерний класс наследует члены родительского класса. Когда мы говорим "член класса", мы имеем в виду переменные экземпляра и методы.

![диаграмма классов после наследования]()

Например, если Wizard - потомок Unit, то класс Wizard автоматически наследует переменные экземпляра и методы, общие для всех юнитов, включая здоровье (health), силу (strength), положение на карте (location), умение перемещаться (goTo()). Но дочерний класс Wizard может иметь собственные переменные экземпляра и методы. Кроме того, методы можно переопределять, т.е. в классе-наследнике можно завести метод с таким же именем и параметрами как в базовом классе. 

Переменные экземпляра не переопределяются, так как в этом нет необходимости. Они не описывают специфическое поведение, дочерний класс и так может присвоить им любые значения. 

Наследование в Java обозначается ключевым словом extends. Наследоваться можно только от одного класса.
```java
class Wizard extends Unit {

}
```
## Аннотация @Override
Хорошая практика, ставить на переопределенных методах аннотацию @Override. Она явно декларирует ваше намерение переопределить одноименный метод базового класса.
```java
```  
Это может показаться избыточным, ведь переопределение происходит независимо от наличия аннотации. Однако это полезно для дополнительной самопроверки. Например можно ошибиться в имени метода, или в его параметрах, и таким образом создать самостоятельный метод не перекрывающий метод базового класса. Или объявление базового класса, может изменится без вашего ведома, и сигнатуры методов разойдутся. При наличии аннотации @Override компилятор сразу укажет вам на эту проблему. 
