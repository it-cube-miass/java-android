<!-- В этом модуле мы поговорим о том, как из Java-программы полазать по диску, по файловой системе и что-нибудь прочитать или записать. 

Тема, казалось бы достаточно простая, но на самом деле здесь есть, что обсудить.  
Дело в том, что в Java за ввод/вывод отвечает достаточно большое количество классов. И некоторые из них даже дублируют функциональность друг друга. Поэтому важно сложить общую картину и раставить все по полочкам.  -->

Начиная разговор о потоках ввода-вывода, в первую очередь поставим главную задачу — программа должна иметь возможность передать данные кому-то еще.  
Современная программа не существует в вакууме, в сегодняшних условиях подавляющее большинство программ требует интеграции с другими. Интеграция всегда подразумевает передачу данных. Т.е. одна программа как-то передает данные в другую. Нам, как программистам,. нужен некий механизм передачи данных.

Дальше уже идет специализация — каким образом это можно сделать. На сегодня основных вариантов три:
- файловая система — одна программа записывает в файл и другая программа читает данные из файла
- сетевое взаимодействие — две программы используют сеть для передачи данных друг другу
- передача из одной области памяти в другую. Данный вариант достаточно часто используется в рамках одной программы, но это не обязательно

Сосредоточимся на передаче данных. Что это с технической точки зрения? Да очень просто — надо “переслать” некое количество байт. Т.е одна программа (отправитель), используя какой-то механизм, “отправляет” байты, а другая (потребитель), используя тот же механизм, “потребляет” эти байты. Причем логично, что байты идут друг за другом от отправителя к потребителю, в виде некоего **потока** байтов.

Причем, важно отметить — ПОТОК данных предполагает, что среда переноса данных может быть разная. Это файловая система, по сути контроллер жесткого диска. Или это сетевая карта, в которую (или из которой) записываются (читаются) байты. Во всех случаях, по сути, вы должны записать/считать байт по определенному адресу. Дальше в дело вступает электроника — вы записали байт по адресу, контроллер той же сетевой карты отправит это байт в сеть, где контроллер сетевой карты на другом компьютере поместит этот байт по определенному адресу, который будет доступен для чтения.

Таким образом можно рассматривать механизм потоков, как инструмент. С помощью которого вы как-бы подключаетесь к источнику данных (в случае чтения) или приемнику данных (в случае записи) и после подключения вам просто надо либо читать оттуда, либо писать туда.

Удобно представить это, как некоторую “трубу”, с одной стороны которой наш код, а с другой стороны все, что может принимать (или порождать) набор байтов. Мы просто “заливаем” в эту трубу байты. А как они там на другом конце трубы попадают в приемник — не наше дело. Я просто использую “трубы” под каждый вид приемника — для файла, для сети.

## Типы потоков
По направлению движения данных потоки можно разделить на две группы:
- поток ввода (Input) — данные поступают из потока в нашу программу. Мы их читаем из этого потока
- поток вывода (Output) — данные поступают в поток из нашей программы. Мы их пишем в этот поток

Вторым критерием разделения может служить ТИП передаваемых данных. Да-да, байты не всегда являются удобным вариантом передачи — есть еще текст. Символы. Я надеюсь, вы помните, что символ в Java это тип char и он занимает **два** байта. Так вот, передача двух байтов как одного целого числа имеет сложность — какой байт должен идти первым? Есть такая неприятная ситуация — в разных операционных системах этот вопрос решается по-разному. (Вы можете поискать информацию в Интернете на тему big endian little endian и узнать, как непросто бывает подружить Windows и Linux или просто Linux на разных компьютерах.) В результате передача символов длиной в два байта требует дополнительных усилий. Поэтому и появилось такое разделение:
- поток байтов
- поток символов

В итоге мы получаем 4 типа потоков. Для каждого из этих типов Java предлагает отдельный базовый абстрактный класс.  
Почему абстрактный? Потому, что у нас есть специализация — файлы, сеть, память. И расширяя базовый класс, специальный класс решает свои специальные задачи. Но базовые функции для всех одинаковые. Что удобно — все специальные потоки по своей сути одно и тоже. Это дает гибкость и универсальность. Вот эти классы:
- InputStream — поток для чтения байтов (поток ввода)
- OutputStream — поток для записи байтов (поток вывода)
- Reader — поток для чтения символов (поток ввода)
- Writer — поток для записи символов (поток вывода)

Основной функцией для потоков ввода является метод read в нескольких модификациях. Разница для InputStream и Reader состоит только в том, что первый читает байты (byte), а второй — символы (char).  
Вполне логично вытекает название основного метода для классов OutputStream и Writer — метод write. Тоже в нескольких модификациях.

## Основные действия с потоком
Схема работы с потоком в упрощенном виде выглядит так:
1. Создается экземпляр потока
2. Поток открывается (для чтения или записи)
3. Производится чтение из потока/запись в поток
4. Поток закрывается

Первые два пункта часто совмещены в рамках одного действия. По сути потоки можно представить как трубу, в которую “заливаются” байты или символы. Причем что еще интереснее, эти трубы можно “склеивать” друг с другом. Т.е один поток может передавать данные в другой, предварительно как-то их модифицируя.
Этот прием мы еще увидим, а пока давайте решим простую задачу — запишем строку в файл. В текстовый файл. Т.е. Нам потребуется поток для символов — Writer. Потом мы прочитаем этот файл — и для этого используем Reader.
Чуть выше уже говорилось, что Reader и Writer — абстрактные классы. Для работы с файлами нам потребуются уже конкретные и это будут FileReader и FileWriter.
