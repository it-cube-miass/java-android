В последних нескольких главах мы использовали и обсуждали довольно много различных атрибутов. Думаю, что стоит сделать краткое резюме и продолжить исследование некоторых наиболее распространенных из них.

## Задание размеров используя dp
Как мы знаем, существуют тысячи различных устройств Android. Чтобы попытаться создать систему измерения, которая работает на разных устройствах, Android использует в качестве единицы измерения независимые от плотности пиксели (density-independent pixels), или dp. Способ, которым это работает, заключается в первом вычислении плотности пикселей на устройстве, на котором работает приложение.
>Мы можем рассчитать плотность, разделив горизонтальное разрешение на горизонтальный размер экрана в дюймах. Все это делается на лету на устройстве, на котором работает наше приложение.

Все, что мы должны сделать, это использовать dp в сочетании с числом, при настройке размера различных атрибутов наших виджетов. Используя измерения, не зависящие от плотности, мы можем создавать макеты, которые масштабируются для создания однородного внешнего вида на как можно большем количестве различных экранов.

Значит, проблема решена? Мы просто используем dp везде, и наши макеты будут работать везде одинакого? К сожалению, использование dp при настройке размеров - это только часть решения. Дальше мы увидим больше приемов, как сделать наше приложение хорошо выглядящем на различных экранах.

Например, мы можем повлиять на высоту и ширину виджета, добавив следующий код к его атрибутам:
```xml
android:height="50dp"
android:width="150dp"
```
В качестве альтернативы, мы можем использовать окно атрибутов и добавлять их через соответствующие поля редактирования. Выбор будет зависеть только от ваших личных предпочтений.

Мы также можем использовать те же единицы dp для установки других атрибутов, таких как поля и отступы. Мы рассмотрим их более внимательно через минуту.

## Задание размера шрифта используя sp
Другая зависящая от устройства единица измерения, используемая для задания размера шрифтов Android, - масштабируемые пиксели (scalable pixels), или sp. Единица измерения sp используется для шрифтов и зависит от плотности пикселей точно так же, как и dp.

Дополнительный расчет, который Android-устройство будет использовать при принятии решения о том, насколько большим будет ваш шрифт, основанный на значении sp, который вы используете, - это собственные настройки размера шрифта пользователя. Если вы тестируете свое приложение на устройствах и эмуляторах с обычными шрифтами, то пользователь, у которого настройки шрифта установлены на большие, увидит что-то отличное от того, что вы видели во время тестирования.

Если вы хотите поиграться с настройками размера шрифта, вашего Android устройства, вы можете это сделать, выбрав Settings | Display | Font size

![font size]()

Как мы видим, есть довольно много настроек, и если вы попробуете выставить огромный, то и разница будет огромная! :)

Мы можем установить размер шрифтов, используя sp в любом виджете, который имеет текст. Это включает Button, TextView и все элементы пользовательского интерфейса в палитре Text, а также некоторые другие. Делается это устанавливая свойство textSize:
```xml
android:textSize="50sp"
```

## Определение размера при помощи wrap или match
Мы также можем решить, как размеры элементов пользовательского интерфейса ведут себя по отношению к содержащему их родительскому элементу. Делается это установкой атрибутов layoutWidth и layoutHeight в значение wrap_content, либо match_parent. Например:
```xml
android:layout_width="match_parent"
android:layout_height="match_parent"
```
Тогда элемент будет расширяться как по высоте, так и по ширине, чтобы соответствовать родительскому.

Если же задать wrap_content
```xml
android:layout_width="wrap_content"
android:layout_height="wrap_content"
```
Это приводит к тому, что виджет будет настолько большой, насколько ему нужно, чтобы обернуть свое содержимое (ширина и высота в dp и текст в sp).

## Использование внутренних и внешних отступов
Если вы когда-либо занимались веб-дизайном, то вам должны быть очень хорошо знакомы два следующих термина. Внутренний отступ (padding) - это пространство от края виджета до начала содержимого в виджете. Внешний отступ (margin) - это пространство за пределами виджета, которое остается между другими виджетами, включая поля других виджетов, если они есть. Вот визуальное представление:

![margin padding]()

Мы можем их установить простым способом:
```xml
android:layout_margin="23dp"
android:padding="10dp"
```
Обратите внимание на небольшое различие в названиях атрибов. Внутренний отступ просто называется padding, а внешний называется layout_margin. Это отражает тот факт, что padding влияет только на сам виджет пользовательского интерфейса, а margin может влиять и на другие виджеты в макете.

Мы можем указывать различные верхние, нижние, левые и правые отступы, как показано ниже:
```xml
android:layout_marginTop="23dp"
android:layout_marginBottom="43dp"
android:paddingLeft="5dp"
android:paddingRight="10dp"
```
Указание отступов для виджета является необязательным, и если ничего не указано, то будет приниматься нулевое значение.  
Мы также можем указать отступ для всех сторон, а затем, ниже указать для какой-то отдельно:
```xml
android:padding="10dp"
android:paddingLeft="5dp"
```
Мы даже можем указать отрицательные значения отступов, для создания перекрывающихся виджетов.

Вероятно, становится очевидным, что способы, которыми мы проектируем наши макеты чрезвычайно гибки и потребуется некоторая практика, чтобы достичь точных результатов с этими многочисленными вариантами. Давайте рассмотрим еще несколько атрибутов, а затем мы пойдем дальше и поиграемся со стильным макетом — CardView.

## Использование свойства layout_weight
Значение веса (weight) виджета - это относительное количество по сравнению с другими элементами пользовательского интерфейса. Таким образом, чтобы layout_weight был полезен, нам нужно присваивать его для двух и более элементов.  
Использование layout_weight особенно полезно, если мы хотим, чтобы разделения пространства экрана между частями пользовательского интерфейсав оставалось неизменным, независимо от размера экрана.

Использование layout_weight в сочетании с sp и dp может обеспечить простую и гибкую компоновку:
```xml
<Button
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight=".2"
        android:text="one tenth" />

<Button
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight=".3"
        android:text="two tenths" />

<Button
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight=".5"
        android:text="three tenths" />
```
![layout_weight]()

Обратите внимание, что все атрибуты layout_height имеют значение 0dp. Фактически layout_weight заменяет свойство layout_height. Контекст, в котором мы используем layout_weight, важен, иначе он не будет работать. Мы скоро увидим это в реальном проекте.

## Использование gravity
Гравитация (gravity) может быть нашим другом, и она может быть использована многими способами в наших планах. Точно так же, как гравитация в Солнечной системе, она влияет на положение предметов, перемещая их в заданном направлении. Как будто на них действует гравитация.  
Лучший способ увидеть, что может сделать gravity, это посмотреть на некоторые примеры кода и результаты
```xml
android:gravity="left|center_vertical"
```
![gravity]()

Обратите внимание, что содержимое виджета (в данном случае текст кнопки) действительно выровнено слева и по центру вертикально.

Кроме того, виджет может влиять на свое собственное положение в элементе родителе с помощью атрибута layout_gravity
```xml
android:layout_gravity="left"
```
![layout_gravity]()

layout_gravity позволяет воздействовать на различные виджеты, в пределах одного элемента-родителя, так же, как если бы родитель имел несколько различных гравитаций.

На содержимое всех виджетов в макете может влиять свойство gravity их родительского макета. Используется тот же атрибут, что для виджета
```xml
android:gravity="left"
```

Различных атрибутов гораздо больше, чем те, что мы обсудили. Многие из них нам пока не нужны, а некоторые совершенно непонятны, и скорее всего вам никогда не понадобятся в карьере Android-разработчика. Но другие довольно часто используются, включая: background, textColor, alignment, typeface, visibility и shadowColor. Часть из них мы затронем при создании макета.
