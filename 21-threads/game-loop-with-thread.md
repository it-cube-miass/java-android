Теперь, когда мы узнали об игровом цикле и потоках, мы можем собрать все это вместе, чтобы реализовать наш игровой цикл в проекте Living Drawing.

Мы добавим весь код для игрового цикла, включая написание двух методов в классе **MainActivity**, чтобы запускать и останавливать поток, который будет управлять циклом.

> Можете ли вы угадать, как класс, основанный на активности, начнет и остановит поток в классе LiveDrawingView?

## Реализация Runnable и предоставление метода run
Обновите объявление класса путем реализации интерфейса Runnable, как мы обсуждали ранее:
```java
public class LiveDrawingView extends SurfaceView implements Runnable {
```
Обратите внимание, что в коде появилась новая ошибка. Наведите указатель мыши на слово Runnable, и вы увидите сообщение, информирующее вас о том, что нам снова нужно реализовать метод run.
```java
    @Override
    public void run() {

    }
```
Ошибка исчезла, и теперь мы можем объявить и инициализировать объект потока.

## Кодирование потока
Объявите некоторые переменные экземпляра, под всеми другими нашими членами в классе **LiveDrawingView**:
```java
    private Thread thread = null;
    private volatile boolean drawing;
    private boolean paused = true;
```
Теперь мы можем запустить и остановить поток. Подумайте о том, где мы могли бы это сделать. Помните, что приложение должно реагировать на запуск и остановку операционной системы.

## Запуск и остановка потока
Нам нужно запускать и останавливать поток. Мы видели код, который нам нужен, Но когда и где мы должны это сделать? Давайте напишем два метода, один для запуска и один для остановки, а затем мы сможем обдумать, когда и откуда следует вызывать эти методы. Добавьте эти два метода в класс LiveDrawingView. Если их имена и звучат знакомо, то не случайно:
```java
    public void pause() {
        drawing = false;
        try {
            thread.join();
        } catch (Exception e) {
            Log.e("Error:","joining thread");
        }
    }

    public void resume() {
        drawing = true;
        thread = new Thread(this);
        thread.start();
    }
```
Итак, у нас есть методы **pause** and **resume**, которые останавливают и запускают объект Thread.

Обратите внимание, что новые методы являются общедоступными и поэтому доступны за пределами класса любому другому классу, имеющему экземпляр **LiveDrawingView**.

Помните, что **MainActivity** имеет полностью объявленный и инициализированный экземпляр LiveDrawingView?

Так давайте использовать жизненный цикл активности для вызова этих двух новых методов.

## Использование жизненого цикла активности для запуска и остановки потока
Обновите переопределенные методы **onResume** и **onPause** в **MainActivity**:
```java
    @Override
    protected void onResume() {
        super.onResume();
        liveDrawingView.resume();
    }

    @Override
    protected void onPause() {
        super.onPause();
        liveDrawingView.pause();
    }
```
Теперь наш поток будет запущен и остановлен, когда операционная система возобновит и приостановит наше приложение. Помните, что **onResume** вызывается после **onCreate** при первом создании приложения, а не только после возобновления работы. Код внутри **onResume** и **onPause** использует объект ```liveDrawingView``` для вызова методов **resume** и **pause**, которые, в свою очередь, содержат код для запуска и остановки потока. При запуске потока, выполняется метод **run**. Именно в этом методе (в **LiveDrawingView**) мы будем кодировать наш игровой цикл. Давайте сделаем это прямо сейчас.

## Кодирование метода run
Хотя наш поток настроен и готов к работе, ничего не происходит, потому что метод **run** пуст.
```java
    @Override
    public void run() {
        while (drawing) {
            long frameStartTime = System.currentTimeMillis();
            if (paused) {
                update();
            } 
            draw();

            long timeThisFrame = System.currentTimeMillis() - frameStartTime;
            if (timeThisFrame > 0) {
                FPS = MILLIS_IN_SECONDS / timeThisFrame;
            }
        }
    }
```
Обратите внимание, что в Android Studio есть ошибка. Это происходит потому, что мы еще не написали метод **update**. Давайте быстро добавим пустой метод **update**.
```java
    private void update() {
    }
```
Теперь подробно обсудим, как код в методе **run** достигает целей нашего игрового цикла.

Инициируется цикл **while** с условием ```drawing``` и обертывает остальную часть кода внутри **run**, в результате поток будет запущен, ```drawing``` равен **true**.

Первая строка кода внутри цикла **while** объявляет и инициализирует локальную переменную ``` frameStartTime``` с текущим временем в милисекундах. Статический метод **currentTimeMillis** класса **System** возвращает это значение. Если мы хотим измерить, сколько времени потребовалось на отрисовку кадра, то нам нужно знать, в какое время он начал отрисовываться.

Далее, все еще находясь в цикле **while**, мы проверяем, приостановлено ли приложение, и если это так, то обновляем данные вызвам метод **update**.

Метод **draw** вызывается для отрисовки всех объектов. Далее объявляется и инициализируется локальная переменная ```timeThisFrame``` с тем временем, которое потребовалось для завершения всего кадра (обновление и отрисовка).

Если ```timeThisFrame``` больше нуля, то получаем новое значение для ```fps```, которое мы сможем использовать в следующем кадре для обновления положения всех частиц. Они будут использовать это значение, чтобы убедиться, что двигаются правильно исходя из своей скорости. (Этим мы займемся в следующей главе)

Нажмите кнопку **Run 'app'** в Android Studio, и тяжелая работа, что мы проделали оживет. Мы создали систему реального времени с игровым циклом и потоками. Если вы запустите его на реальном устройстве, то на этом этапе вы легко достигнете 60 кадров в секунду.
