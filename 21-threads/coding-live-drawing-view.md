Первое, что мы сделаем, это решим проблему того, что наш класс LiveDrawingView не относится к типу View. Обновите объявление класса, как выделено, следующим образом:
```java
public class LiveDrawingView extends SurfaceView {
```
**SurfaceView** является потомком класса **View**, и теперь **LiveDrawingView**, по наследству, также является типом **View**.

> Помните, что именно из-за полиморфизма мы можем отправлять всем потомков **View** в метод **setContentView** в классе **LiveDrawingActivity**.

Существует довольно много потомков **View**, которые мы могли бы расширить, но мы увидим, что **SurfaceView** имеет некоторые специфические функции, которые идеально подходят для интерактивных приложений реального времени.

Однако у нас все еще есть ошибки как в этом классе, так и в LiveDrawingActivity. И то, и другое связано с отсутствием подходящего метода конструктора.

Вот скриншот, показывающий ошибку в классе LiveDrawingView:

![](assets/error-surface-view.png)

Ошибка в **MainActivity** более очевидна; мы вызываем метод, которого не существует. Однако ошибка, показанная на скриншоте, менее понятна. Давайте теперь обсудим ошибку в **LiveDrawingView**.

Класс **LiveDrawingView** теперь, когда он является **SurfaceView**, должен быть снабжен конструктором. Поскольку класс **SurfaceView** реализует несколько различных конструкторов, мы должны специально реализовать один из них или написать свой собственный.

Так как ни один из предоставленных конструкторов **SurfaceView** не является именно тем, что нам нужно, мы предоставим наш собственный.

> Если вам нужно узнать детали о классе Android, просто погуглите его. Введите имя класса, а затем API. Google почти всегда будет предоставлять ссылку на соответствующую страницу на веб-сайте разработчика Android в качестве верхнего результата. Вот прямая ссылка на страницу [SurfaceView](https://developer.android.com/reference/android/view/SurfaceView.html).

**MainActivity** также требует, чтобы мы создали подходящий конструктор, который будет соответствовать передаваемым аргументам:
```java
liveDrawingView = new LiveDrawingView (this, size.x, size.y);
```
Помните, что **LiveDrawingView** не может видеть переменные в **MainActivity**. С помощью ```this```, **MainActivity** предоставляет **LiveDrawingView** ссылку на себя, а также размер экрана в пикселях, содержащихся в ```size.x``` и ```size.y```. Давайте добавим конструктор, который будет соответствовать вызову из **MainActivity**, и решим обе проблемы сразу.
```java
    public LiveDrawingView(Context context, int x, int y) {
        super(context);
    }
```
Теперь у нас нет ошибок в наших классах **LiveDrawingView** и **MainActivity**.

На этом этапе мы могли бы запустить приложение и увидеть, что использование **LiveDrawingView** в качестве вьюхи в **setContentView** сработало и что у нас есть красивый пустой экран, готовый нарисовать что-нибудь нам нужное. Попробуйте это, если хотите, а мы будем кодировать класс **LiveDrawingView** дальше так, чтобы он что-то делал.

Мы будем возвращаться к этому классу постоянно в течение всего проекта. То, что мы сделаем прямо сейчас, - это подготовим основы, чтобы потом мы могли добавить экземпляры ParticleSystem.

Чтобы достичь этого, сначала мы добавим кучу переменных экземпляра, а затем добавим некоторый код внутри конструктора, чтобы настроить объект, когда он будет создан в **MainActivity**.

Далее мы перейдем к кодированию метода рисования, сделав некоторые шаги, чтобы рисовать на экране 60 раз в секунду, и мы также увидим знакомый код, который использует наших старых друзей: **Canvas**, **Paint** и **drawText**, из предыдущей главы.

Нам ещё нужно обсудить несколько теоретических вопросов:

* как мы будем определять время анимации частиц?
* игровой цикл

Эти последние две темы, позволят нам затем добавить окончательный код этой главы и увидеть наше приложение для рисования в действии.

> Игровой цикл - это концепция, которая описывает, как виртуальные системы могут обновляться и рисовать себя одновременно с возможностью их изменения / взаимодействия с пользователем.

## Добавление переменных экземпляра
Добавьте переменные, как показано в следующем коде, после объявления **LiveDrawingView**, но перед конструктором, а затем импортируйте необходимые дополнительные классы:
```java
    private final boolean DEBUGGING = true;

    private SurfaceHolder holder;
    private Canvas canvas;
    private Paint paint;

    private long fps;
    private final int MS_IN_SECONDS = 1000;

    private int screenX;
    private int screenY;
    private int fontSize;
    private int fontMargin;
```
Обязательно изучите код, и тогда мы сможем поговорить об этом.

Обратите внимание, что все переменные объявлены ```private```. Вы можете с радостью удалить все эти модификаторы доступа, и код все равно будет работать, но, поскольку у нас нет необходимости обращаться к любой из этих переменных за пределами этого класса, разумно гарантировать, что это никогда и не произойдет, объявив их ```private```.

Первая переменная - это состояние отладки. Мы объявили его ```final```, потому что не хотим изменять его значение во время выполнения приложения. Обратите внимание, что объявление его ```final`` не мешает нам переключать его значение вручную, когда мы хотим выключить отладочный режим.

Следующие три, будут обрабатывать рисунок на экране. Обратите внимание на **SurfaceHolder**, который мы не видели раньше. Класс **SurfaceHolder** необходим для того, чтобы можно было выполнять рисование. Буквально, это объект, который удерживает поверхность рисунка.

Следующие две переменные дают нам некоторое представление о том, что нам нужно для достижения нашей плавной и последовательной анимации.
```java
    private long fps;
    private final int MS_IN_SECONDS = 1000;
```
Мониторинг и измерение скорости каждого кадра анимации необходимо для контроля, что все частицы движутся именно так, как они должны двигаться.

Значение fps будет вычисляться каждый кадр анимации, примерно 60 раз в секунду. Оно будет передаваться в каждый из объектов частиц (каждый кадр анимации), чтобы они знали, сколько времени прошло, а затем могли вычислить, как далеко нужно двигаться.

Константа ```MS_IN_SECOND``` инициализируется значением 1000. В одной секунде действительно 1000 миллисекунд. Мы будем использовать эту константу в расчетах, она сделает наш код более четким, чем если бы мы использовали буквальное значение 1000.

Следующий фрагмент кода, продублирован здесь для удобства:
```java
    private int screenX;
    private int screenY;
    private int fontSize;
    private int marginSize;
```
Переменные ```screenX``` и ```screenY``` будут содержать горизонтальное и вертикальное разрешение экрана. Помните, что они передаются из **MainActivity** в конструктор?  
Переменные ```fontSize``` и ```marginSize```, будут инициализированы на основе размера экрана в пикселях.

## Кодирование конструктора
Добавьте в конструктор следующий код:
```java
    screenX = x;
    screenY = y;
    fontSize = screenX / 20;
    marginSize = screenX / 75;
    holder = getHolder();
    paint = new Paint();
```
Мы инициализируем ```fontSize``` и ```marginSize``` как долю ширины экрана в пикселях. Эти значения немного произвольны, но они работают, и мы будем использовать их, чтобы аккуратно выровнять текст на экране.

Дальше, мы инициализируем наши объекты **Paint** и **SurfaceHolder**. C **Paint** все просто. Для инициализации ```holder``` использует метод **getHolder**, который является методом класса **SurfaceView**.

## Кодирование метода draw
Добавьте метод **draw**, сразу после метода конструктора. Там будет пара ошибок в коде. Сначала мы разберемся с ними, а затем подробно расскажем о том, как метод **draw** будет работать в отношении SurfaceView.
```java
    private void draw() {
        if (holder.getSurface().isValid()) {
            canvas = holder.lockCanvas();

            canvas.drawColor(Color.BLACK);
            if (DEBUGGING) {
                printDebugginText();
            }

            holder.unlockCanvasAndPost(canvas);
        }
    }
```
У нас есть две ошибки. Первая из них заключается в том, что класс **Color** нуждается в импорте.

Вторая ошибка - это вызов printDebuggingText. Этого метода еще не существует. Добавим его сейчас.

### Добавление метода printDebugginText
Добавьте следующий код после метода **draw**:
```java
    private void printDebugginText() {
        int startX = 150;
        int startY = marginSize;
        paint.setTextSize(fontSize);
        canvas.drawText("fps: " + fps, startX, y1, paint);
    }
```
Переменные startX и startY - это просто предположение о хорошей позиции по горизонтали и вертикали, чтобы начать печатать отладочный текст.

Эти два значения затем используются для размещения строки текста на экране, которая показывает текущие кадры в секунду. Поскольку этот метод вызывается из **draw**, который, в свою очередь, будет вызываться из игрового цикла, эта строка текста будет постоянно обновляться до шестидесяти раз в секунду.

Теперь давайте рассмотрим код в методе **draw**.

## Разбор метода draw и класса SurfaceView
Что является совершенно новым, находится в самом начале метода **draw**.
```java
    if (holder.getSurface().isValid()) {
```
Если эта строка возвращает true, это значит, что область памяти, которой мы хотим управлять для отрисовки кадра, доступна.

То, что происходит внутри этих методов (особенно первого), довольно сложно. Они необходимы, потому что все наши отрисовки и другая обработка (например, перемещение объектов) будут происходить асинхронно с кодом, который обрабатывает вводимые пользователем данные и прослушивает сообщения операционной системы. Это не было проблемой в предыдущем проекте, потому что наш код там просто рисовал один кадр.

Теперь, когда мы хотим выполнять код 60 раз в секунду, нам нужно быть уверенными, что у нас есть доступ к памяти, прежде чем мы начнем что-то с ней делать.

Итак, эта строка кода проверяет, использует ли какая-то другая часть нашего кода или сам Android, в текущий момент времени, необходимую часть памяти. Если она свободна, то выполняется код внутри оператора if.

Первая строка кода, выполняемая внутри оператора **if**, вызывает **lockCanvas**, так что если другая часть кода попытается получить доступ к памяти, пока наш код обращается к ней, он не сможет этого сделать.

Затем, мы делаем все наши рисунки.

И наконец, в методе **draw** есть следующая строка:
```java
holder.unlockCanvasAndPost(canvas);
```
Метод **unlockCanvasAndPost** отправляет наш объект **Canvas** (canvas) для рисования на экран и освобождает блокировку, чтобы другие области кода могли использовать его снова, прежде чем весь процесс начнется снова. Этот процесс будет происходить каждый кадр анимации.

Ок, у нас есть метод **draw**. Однако у нас все еще нет механизма, который снова и снова будет его вызывать. Пока что, мы его не вызываем даже один раз. Но счачала нам нужно поговорить о игровом цикле.
