Так что же такое поток? Вы можете думать о потоках в программировании так же, как и о потоках в истории. В одном потоке истории у нас может быть основной персонаж, сражающийся с врагом на фронте, в то время как в другом потоке находиться его семья. Конечно, история не обязательно должна иметь только два потока. Мы могли бы ввести третий. Возможно, эта история также рассказывает о политиках и военных командирах, принимающих решения. И эти решения затем тонко, или не очень тонко, влияют на то, что происходит в других потоках.

Программирование потоков происходит именно так. Мы создаем части (потоки) в нашей программе, которые управляют различными аспектами для нас. В Android потоки особенно полезны, когда нам нужно убедиться, что задача не мешает основному потоку приложения (UI), или если у нас есть фоновая задача, выполнение которой занимает много времени и не должно прерывать основной поток выполнения. 

Используют потоки по следующим причинам:

- Они имеют смысл с организационной точки зрения
- Они являются проверенным способом структурирования программы, которая работает
- Природа системы, над которой мы работаем, вынуждает нас использовать их

В Android мы используем потоки по всем трем причинам одновременно. Это имеет смысл, это работает, и мы должны это сделать, потому что дизайн системы Android требует этого.

Часто мы используем потоки, сами того не зная. Это происходит потому, что мы используем классы, которые используют потоки. Все анимации, которые мы недавно делали, запускались в потоках.

## Проблема потоков
Программы с несколькими потоками могут иметь проблемы. Например, с потоками истории, в которых, если правильная синхронизация не происходит, то все может пойти не так. А что, если наш солдат пошел в бой еще до того, как началась битва или даже война? Странно.

Рассмотрим, что у нас есть переменная ```int x```, представляющая собой ключевой фрагмент данных, который, скажем, используется тремя потоками нашей программы. Что происходит, если один поток немного опережает себя и делает данные "неправильными" для двух других? Эта проблема - проблема корректности, и вызвана она тем, что множество потоков самопроизвольно устремляются к завершению, потому что, в конце концов, они просто тупой код.

Проблема корректности может быть решена путем тщательного контроля за потоками и блокировкой. Блокировка означает - временное предотвращение выполнения в одном потоке, чтобы быть уверенным, что все работает синхронно.

Другая проблема с программами использующих несколько потоков - это проблема взаимоблокировки, когда один или несколько потоков блокируются в ожидании "правильного" момента для доступа к ```int x```, но этот момент никогда не наступает, и в конечном итоге вся программа останавливается.

Возможно, вы заметили, что именно решение первой проблемы (корректность) является причиной второй проблемы (тупик).

К счастью, эта проблема для нас решена. Точно так же, как мы используем класс **Activity** и переопределяем **onCreate**, чтобы знать, когда нам нужно создать наше приложение, мы также можем использовать другие классы для создания и управления нашими потоками. Как и в случае с активностью, нам нужно только знать, как их использовать, а не как они работают изнутри.

Главное, что нам нужно сделать:

- Понять общую концепцию потока, который является точно таким же, как и поток истории, который происходит почти одновременно
- Изучить несколько правил использования потоков

тогда у нас не будет никаких трудностей с написанием Java-кода для создания и работы в потоках. Существует несколько различных классов Android, которые обрабатывают потоки. И эти различные классы потоков применяются в разных ситуациях.

Все, что нам нужно помнить, это то, что мы будем писать части нашей программы, которые работают почти одновременно друг с другом.

> Что значит "почти"? Процессор переключается между потоками. Однако это происходит так быстро, что для нас это выглядит как если бы они работали одновременно.

Давайте взглянем на то, как будет выглядеть наш код потока. 

Мы можем объявить объект типа **Thread** следующим образом:
```java
    Thread ourThread;
```
А потом инициализировать и запустить его:
```java
    ourThread = new Thread(this);
    ourThread.start();
```
Посмотрите на аргумент, который передается конструктору **Thread**. Предполагается, что этот код будет внутри класса **LiveDrawingView**, а не **MainActivity**. Поэтому ```this``` это ссылка на экземпляр класса **LiveDrawingView** (который расширяет SurfaceView).

Кажется очень маловероятным, что когда ботаники в штаб-квартире Android писали класс **Thread**, они знали, что однажды мы будем писать наш класс **LiveDrawingView**. Итак, как же это может сработать?

Класс Thread нуждается в совершенно другом типе, который будет передан в его конструктор. Конструктор потока нуждается в объекте **Runnable**.

> Вы можете проверить это, посмотрев на класс **Thread** на веб-сайте разработчика Android [здесь](https://developer.android.com/reference/java/lang/Thread.html#Thread):

Вы помните, что мы говорили об интерфейсах? Что мы можем реализовать интерфейс, используя ключевое слово **implements** и имя интерфейса после объявления класса, как в следующем коде:
```java
class someClass extends someotherClass implements Runnable {
```
Затем мы должны реализовать абстрактные методы интерфейса. Интерфейс Runnable имеет только один. Это метод **run**.

> Можете проверить это, посмотрев на интерфейс **Runnable** на веб-сайте разработчика Android [здесь](https://developer.android.com/reference/java/lang/Runnable.html)

Затем мы можем использовать ключевое слово Java @override, чтобы определить то, что будет происходить, когда операционная система позволит нашему объекту потока выполнить свой код:
```java
class someClass extends someotherClass implements Runnable{
   @override
   run() {
      // Все, что здесь находится, выполняется в потоке
      // С нашей стороны никаких навыков не требуется
      // Все это обрабатывается Android, классом Thread
      // и интерфейсом Runnable
   }
}
```
В рамках переопределенного метода **run** мы вызовем два метода: один, который мы уже сделали, **draw**, а другой **update** - метод, где будут находиться все наши расчеты и искусственный интеллект. Код будет выглядеть примерно так. Не добавляйте его пока:
```java
@override
public void run() {
 
    // обновление данных для рисунка основываясь на 
    // вводе пользователя и физике 
    update();
 
    // Отрисовка всех ParticleSystems с их обновленным расположением
    draw();
}
```
Когда это необходимо, мы также можем остановить наш поток:
```java
ourThread.join();
```
Теперь все, что находится в методе run, выполняется в отдельном потоке, оставляя поток default или UI для обработки касаний и системных событий. Вскоре мы увидим, как эти два потока взаимодействуют друг с другом.
