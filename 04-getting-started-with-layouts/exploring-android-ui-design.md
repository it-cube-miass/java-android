Мы увидим, что в разработке пользовательского интерфейса Android многое зависит от контекста. То, как влияние атрибута на внешний вид виджета, может зависеть от другого атрибута или даже от атрибута другого виджета. Нелегко выучить это дословно. Лучше всего ожидать постепенного достижения лучших и более быстрых результатов с практикой.

Например, если вы работая с дизайнером, перетаскиваете виджеты по макету, генерируемый XML-код будет довольно сильно отличаться в зависимости от типа макета, который вы используете.

Это происходит потому, что разные типы макетов используют разные средства, чтобы определить положение своих потомков. Например, LinearLayout, который мы рассмотрим далее, работает совсем иначе, чем ConstraintLayout, который был добавлен по умолчанию в наш проект в главе [Начало](../01-begining/README.md)

Это, поначалу, может показаться проблемой или даже плохой идеей. Однако скоро вы поймете, что изобилие вариантов компоновки и их индивидуальные причуды - хорошая вещь, потому что они дают нам почти неограниченный дизайнерский потенциал. 

Однако этот почти неограниченный потенциал сопряжен с некоторой сложностью. Лучший способ начать разбираться с этим - построить несколько рабочих макетов. В этой главе мы расмотрим три: LinearLayout, ConstraintLayout и TableLayout. Мы увидим, как сделать вещи проще, используя отличительные особенности графического режима разработки UI. Мы также уделим некоторое внимание XML, который автоматически генерируется, чтобы сделать наше понимание более четким.

## Макеты (Layouts)
Мы уже видели ConstraintLayout, но есть и другие. Макеты - это строительные блоки, которые группируют вместе другие элементы пользовательского интерфейса. Макеты могут сами содержать и часто содержат другие макеты.

Давайте рассмотрим некоторые часто используемые макеты в Android, потому что знание различных макетов и их плюсов и минусов позволит нам лучше понять, чего можно достичь, и, следовательно, расширить горизонты возможного.

Мы уже видели, что после того, как мы разработали макет, мы можем привести его в действие, используя метод ```setContentView()``` в нашем коде Java.”

Давайте построим три макета с разными типами компоновки, а затем запустим setContentView() в работу и переключимся между ними.
