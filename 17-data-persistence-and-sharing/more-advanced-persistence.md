Давай подумаем, что нам нужно сделать. Мы хотим сохранить кучу заметок во внутреннем хранилище. Более конкретно, мы хотим сохранить строки и связанные с ними булевые значения. Эти строки и логические значения представляют заголовок заметки пользователя, текст заметки, а также является ли это задачей, важным или идеей.

Учитывая то, что мы уже знаем о классе **SharedPreferences**, на первый взгляд, это может показаться не особенно сложным – пока мы не копнем немного глубже в наши требования. Что делать, если пользователь любит наше приложение и в итоге получает 100 заметок? Нам понадобится 100 идентификаторов для пар ключ-значение. Не то чтобы это невозможно, но уже начинает плохо пахнуть. 

Теперь подумайте, что мы хотим улучшить приложение и дать пользователю возможность добавлять к заметкам даты. Android имеет класс **Date**, который идеально подходит для этого. Но когда дело доходит до сохранения данных, внезапно все начинает усложняться.

Как мы будем хранить дату, используя **SharedPreferences**? Он не был предназначен для этого. Мы могли бы преобразовать дату в строку, при сохранении, а потом обратно в дату при выгрузке, но это далеко не просто.

И, поскольку наше приложение растет в функциях, и наши пользователи получают все больше и больше заметок, вся эта история с сохранением данных становится кошмаром. Нам нужен способ сохранения и загрузки объектов Java. Если мы можем просто сохранять и загружать объекты, включая их внутренние данные (строки, логические значения, даты или что-либо еще), наши приложения могут иметь любые данные, которые мы можем придумать, чтобы удовлетворить наших пользователей.

Процесс преобразования объектов данных в биты и байты для хранения на диске называется сериализацией; обратный процесс называется десериализацией. Сериализация сама по себе является обширной темой и далеко не простой. К счастью, есть класс, который справится с большей частью сложности за нас.

## Что такое JSON
JSON расшифровывается как JavaScript Object Notation, и он широко используется в областях, выходящих за рамки Android и языка Java. Больше всего он используется для передачи данных между веб-приложениями и серверами.

К счастью, существуют классы для работы с JSON, доступные в Android, которые почти полностью скрывают сложность процесса сериализации. Изучив еще несколько концепций Java, мы можем быстро начать использовать эти классы и начать сохранять целые объекты Java в хранилище устройства, и не беспокоиться о том, какие примитивные типы составляют объекты.

Классы JSON, по сравнению с другими классами, которые мы видели до сих пор, выполняют операции, которые имеют более высокую вероятность отказа. Чтобы выяснить, почему это так и что с этим можно сделать, давайте рассмотрим исключения в Java.

## Исключения в Java
Все эти разговоры о JSON требуют, чтобы мы изучили новую концепцию Java - исключения. Когда мы пишем класс, который выполняет операции, которые имеют возможность сбоя, особенно по причинам, не зависящим от нас, желательно обозначить это явно в нашем коде, чтобы любой, кто использует наш класс, был готов к такой ситуации.

Сохранение и загрузка данных - это один из таких сценариев, когда сбой возможен вне нашего кода. Представьте, ты пытаетесь загрузить данные, когда SD-карта была удалена или повреждена. Другой пример, где код может потерпеть неудачу - работа с сетевым соединением. Что делать, если пользователь теряет связь при передаче данных?

Исключения Java - это решение подобных ситуаций, и классы для работы с JSON используют их.

Когда мы пишем класс, который использует код с вероятностью сбоя, мы можем подготовить пользователей нашего класса, используя ключевое слово **throws** при описании опасных методов.
```java
public void somePrecariousMethod() throws someException {
   // здесь какой-то код с возможностью сбоя
}
```
Теперь любой код, который использует метод **somePrecariousMethod**, должен будет обработать исключение. Обрабатывают исключения путем обертывания кода в блоки **try** и **catch**.
```java
try {
    //...
    somePrecariousMethod();
    //...
} catch (someException e) {
    Log.e("Exception:" + e, "Oh no!");
    // какие-то действия если возможно
}
```
По желанию, мы также можем добавить блок **finally**, если мы хотим предпринять какие-либо действия после блоков **try** and **catch**:
```java
finally {
    // еще действия 
}
```
В нашем приложении ```Note to Self``` мы предпримем минимум необходимых действий для обработки исключений и просто выведем ошибку в **Logcat**, но вы можете сделать нечно большее. Например: уведомить пользователя, повторить операцию или запустить какой-то умный запасной план.
