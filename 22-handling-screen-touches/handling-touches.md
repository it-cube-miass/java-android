Для начала добавим метод **OnTouchEvent** в класс **LiveDrawingView**:
```java
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        return true;
    }
```
Это переопределенный метод, и он вызывается Android каждый раз, когда пользователь взаимодействует с экраном. Посмотрите на единственный параметр в **onTouchEvent**.

Оказывается, что у ```event``` есть целая куча данных, спрятанных внутри него, и эти данные содержат детали только что произошедшего прикосновения. Операционная система посылает его нам, потому что она знает, что мы, вероятно, будем нуждаться только в некоторых из них.

Сам класс MotionEvent довольно обширен. Он содержит в себе десятки методов и переменных. Мы откроем много из них, но далеко не все.

На данный момент все, что нам нужно знать - это координаты экрана в тот момент, когда палец игрока был перемещен, коснулся экрана или убран.

Некоторые переменные и методы, содержащиеся в ```event```, которые мы будем использовать, включают следующее:

* Метод **getAction**, возвращающий действие, которое было выполнено. К сожалению, он предоставляет эту информацию в слегка закодированном формате, что объясняет необходимость некоторых из следующих переменных.
* Переменная **ACTION_MASK**, которая предоставляет значение, известное как маска, которая может быть использована для фильтрации данных из getAction.
* Переменная **ACTION_UP**, которую мы можем использовать для сравнения, чтобы увидеть, является ли выполненное действие тем, на которое мы хотим ответить (поднятие пальца).
* Переменная **ACTION_DOWN**, --//-- (опускание пальца).
* Переменная **ACTION_MOVE**, --//-- (перемещение).
* Метод **getX** возвращающий горизонтальную координату, где произошло событие.
* Метод **getY** возвращающий вертикальную координату, где произошло событие.

Теперь мы можем запрограммировать метод **onTouchEvent** и увидеть все это в действии.

## Кодирование метода onTouchEvent
Нам нужно управлять движением пальца пользователя по экрану. 
```java
    if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_MOVE ) {
        particleSystems.get(nextSystem).emitParticles(new PointF(event.getX(), event.getY()));

        nextSystem++;
        if (nextSystem > MAX_SYSTEM) {
            nextSystem = 0;
        }
    }
```
Условие if проверяет, был ли тип события тем, что пользователь двигал пальцем. Если это было так, то следующая система частиц ```particleSystems``` вызывает метод **emitParticles**. После этого переменная ```nextSystem``` увеличивается, и проверяется, была ли она последней. Если это было так, то ```nextSystem``` устанавливается в 0, для повторного использование существующих систем частиц в следующий раз, когда это потребуется.

Для обработки нажатий пользователя кнопок, добавим следующий код сразу после предыдущего:
```java
    if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
        if (resetButton.contains(event.getX(), event.getY())) {
            nextSystem = 0;
        }

        if (togglePauseButton.contains(event.getX(), event.getY())) {
            paused = !paused;
        }
    }
```
Условие оператора if проверяет, не коснулся ли пользователь экрана. Если да, то с помощью метод **contains** класса **RectF**, проверяется, было ли это нажатие внутри одной из наших пользовательских кнопок. Если была нажата кнопка ```resetButton```, то все частицы исчезнут, когда mNextSystem будет установлен в ноль. Если кнопка ```togglePauseButton```, то значение ```paused``` инвертируется, в результате чего метод **update** перестанет/начнет вызываться в потоке.

## Обновление printDebugginText
Добавьте следующий код в метод **printDebuggingText**:
```java
    int y1 = debugStart + debugSize;
    int y2 = y1 + marginSize + debugSize;
    int y3 = y2 + marginSize + debugSize;
    paint.setTextSize(debugSize);
    canvas.drawText("FPS: " + FPS, 10, y1, paint);
    canvas.drawText("Systems: "+ nextSystem, 10, y2, paint);
    canvas.drawText("Particles: " + nextSystem * particlesPerSystem, 10, y3, paint);
```
Этот код просто выведет на экран некоторые статистические данные, чтобы сообщить нам, сколько частиц и систем в настоящее время рисуется.

Теперь мы можем увидеть приложение live drawing в действии и поиграть с некоторыми из параметров, которые мы прокомментировали в коде.
