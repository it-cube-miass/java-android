Фрагменты, скорее всего, станут основным элементом почти каждого приложения, которое вы создадите. Они весьма полезны, и есть много причин использовать их. Надо только привыкнуть к ним.

Фрагменты являются многоразовыми элементами приложения, как и любой класс, но, как уже упоминалось ранее, они имеют специальные функции, такие как возможность загружать свой собственный макет и имеют собственные методы жизненного цикла. Это делает их идеальным средством для достижения целей, которые мы обсуждали в разделе ```Приложения в реальном мире```.

Давайте немного углубимся в фрагменты по одной функции за раз.

## Жизненый цикл фрагментов
Мы можем создавать и контролировать фрагменты, очень похожим с активностями способом, переопределяя соответствующие методы жизненного цикла.

### onCreate  
В методе **onCreate** мы можем инициализировать переменные и делать почти все то, что обычно делали бы в методе **onCreate** активностей. Большим исключением из этого правила является инициализация нашего пользовательского интерфейса.

### onCreateView
В этом методе мы, как следует из названия, получаем ссылку на любой из наших виджетов пользовательского интерфейса, настраиваем анонимные классы для прослушивания кликов и многое другое.

### onAttach и onDetach
Эти методы вызываются непосредственно перед тем, как фрагмент вводится в эксплуатацию и выводится из эксплуатации.

### onStart, onPause и onStop
В этих методах мы можем выполнять определенные действия, такие как создание или удаление объектов или сохранение данных, точно так же, как мы делали это в активностях.

> Есть и другие методы жизненного цикла фрагментов, но чтобы начать, этих нам будет достаточно. Если вы хотите изучить детали жизненного цикла фрагмента, вы можете сделать это на веб-сайте разработчика Android по этой [ссылке](https://developer.android.com/guide/components/fragments)

Все это прекрасно, но в первую очередь нам нужен способ создавать наши фрагменты.

## Управление фрагментами с FragmentManager
Класс **FragmentManager** является частью активности. Мы используем его для инициализации фрагментов, добавления фрагментов в макет активности и завершения работы фрагмента. Мы уже видели **FragmentManager** раньше, когда инициализировали **FragmentDialogs**.

Следующий код показывает, как мы использовали **FragmentManager**, передаваемый в качестве аргумента для создания всплывающего диалогового окна:
```java
button.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        DialogShowNote dialog = new DialogShowNote();
        dialog.sendNoteSelected(tempNote);
        dialog.show(getFragmentManager(), "123");
    }
});
```
В то время я просил вас не беспокоиться об аргументах вызова метода. Второй аргумент - это идентификатор фрагмента. Скоро мы увидим подробнее, как использовать FragmentManager, а также идентификатор фрагмента.

**FragmentManager** делает именно то, что предполагает его название. Здесь важно, что у активности есть только один **FragmentManager**, но он может позаботиться о многих фрагментах. Это как раз нам и нужно, чтобы иметь несколько макетов с поведением в одном приложении.

**FragmentManager** также вызывает различные методы жизненного цикла фрагментов, за которые он отвечает. Это отличается от методов жизненного цикла активности, которые вызываются Android, но они тесно связаны, и **FragmentManager** вызывает многие методы жизненного цикла фрагмента в ответ на вызываемые методы жизненного цикла активности. Как обычно, нам не нужно слишком беспокоиться о этом, правда при условии, что мы реагируем соответствующим образом в каждой ситуации.
