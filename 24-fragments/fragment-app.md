Давайте построим фрагмент в его простейшей возможной форме, чтобы мы могли понять, что происходит, прежде чем в последующих главах мы начнем производить фрагменты повсюду.

Создайте новый проект под названием ```Simple Fragment```, используя шаблон **Empty Activity**.

> Обратите внимание, что есть возможность создать проект с фрагментом, но мы будем учиться больше делать все сами с нуля.

Переключитесь на activity_main.xml и удалите **TextView** ```Hello world!```.

Выберите корневой ConstraintLayout и измените его свойство **id** на ```fragmentHolder```. Теперь мы сможем получить ссылку на этот layout в коде Java и, как следует из названия свойства id, добавим к нему фрагмент.

Далее мы создадим макет, который будет определять внешний вид нашего фрагмента. Щелкните правой кнопкой мыши на папке **layout** и выберите команду **New | Layout resource file**. В поле **File name** введите ```fragment_layout``` a в **Root Element** ```LinearLayout```. Ок, новый макет типа LinearLayout создан.

Добавьте в него кнопку, в любое место, сделайте у нее свойство **id** равным ```button```.

Теперь, когда у нас есть простой макет для нашего фрагмента, давайте напишем немного Java-кода.

> Обратите внимание, что вы можете создать фрагмент, просто перетащив его из панели **Palette**, но делать это таким образом гораздо менее гибко и управляемо, а гибкость и контроль - это большие преимущества для фрагментов. Создавая класс, расширяющий **Fragment**, мы можем сделать из него столько фрагментов, сколько захотим.

Создайте новый класс **SimpleFragment** в папке, содержащую файл MainActivity.

В классе SimpleFragment, измените код, чтобы отнаследоваться от класса **Fragment**.

Добавьте следующие переменные экземпляра
```java
    String myString;
    Button button;
```
Теперь переопределите метод **onCreate**. Внутри него инициализируем **myString** в значение ```Hello from SimpleFragment```:
```java
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        myString = "Hello from SimpleFragment";
    }
```
Все что мы сделали, очень похоже на то, что мы делали для наших предыдущих приложений, только с использованием класса **Activity**. Однако есть разница, мы не установили представление или не пытались получить ссылку на кнопку.

При использовании фрагмента нам нужно сделать это в методе **onCreateView**. Давайте переопределим его и посмотрим, как мы устанавливаем представление и получаем ссылку на кнопку.
```java
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.fragment_layout, container, false);
        button = (Button) view.findViewById(R.id.button);

        return view;
    }
```
Чтобы понять предыдущий блок кода, мы должны сначала посмотреть на сигнатуру метода **onCreateView**. Обратите внимание, что в начале метода указано, что он должен возвращать объект типа **View**

Далее, у нас есть три параметра. Первый ```inflater``` мы используем для раздувания макета, содержащегося в файле ```fragment_layout.xml``` и инициализации переменной view полученным результатом. Класс **Fragment** не предоставляет метода **setContentView** как в активности.

Мы также используем ```container``` в качестве аргумента в методе inflate. Переменная ```container``` - это будет ссылка на layout в activity_main.xml.

Параметр ```container``` типа **ViewGroup** позволяет любой активности с любым layout быть контейнером для нашего фрагмента. Это исключительно гибко и делает наш код фрагмента в значительной степени многоразовым.

<!-- Третий аргумент, который мы передаем для раздувания, является ложным, что означает, что мы не хотим, чтобы наш макет был немедленно добавлен к содержащему его макету. Мы сделаем это сами в ближайшее время из другой части кода. -->

Третий параметр **onCreateView** - это Bundle savedInstanceState, который помогает нам поддерживать данные, хранящиеся в наших фрагментах.

Теперь, когда у нас есть раздутый макет, содержащийся во ```view```, мы можем использовать его, чтобы получить ссылку на кнопку, а так же использовать его в качестве возвращаемого значения для вызывающего кода, как это требуется
```java
    button = (Button) view.findViewById(R.id.button);

    return view;
```
Теперь мы можем добавить анонимный класс для прослушивания кликов по нашей кнопке обычным способом. В методе onClick мы покажем всплывающее сообщение **Toast**, чтобы продемонстрировать, что все работает.

Добавьте этот код непосредственно после инициализации ```button``` в методе **onCreateView**:
```java
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            Toast.makeText(getActivity(), myString, Toast.LENGTH_SHORT).show();
        }
    });
```

> Напомним, что вызов ```getActivity()```, используемый в качестве аргумента в **makeText**, получает ссылку на активность, содержащую фрагмент. Это необходимо для отображения всплывающего сообщения. Мы также использовали метод **getActivity** в классах на основе **FragmentDialog** в приложении ```Note to self```.

Чтобы приложение заработало, нам требуется сделать еще один шаг. Нужно создать экземпляр **SimpleFragment** и инициализировать его соответствующим образом. Именно здесь необходим **FragmentManager**.
Добавьте этот код в метод **onCreate** MainActivity.java сразу после вызова setContentView:
```java
    FragmentManager fragmentManager = getSupportFragmentManager();
    Fragment fragment = fragmentManager.findFragmentById(R.id.fragmentHolder);

    if (fragment == null) {
        fragment = new SimpleFragment();
        fragmentManager.beginTransaction()
                .add(R.id.fragmentHolder, fragment)
                .commit();
    }
```
Теперь запустите приложение и с посмотрите на нашу кликабельную кнопку, которая отображает сообщение с помощью класса **Toast**.


